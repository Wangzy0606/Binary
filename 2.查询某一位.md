这个操作 `(X >> n) & 1` 可以查询数字 `X` 的第 `n` 位是 `0` 还是 `1`，其原理基于 **二进制移位（Bit Shifting）** 和 **位掩码（Bit Masking）**。下面逐步解释它的工作原理：

---

## **1. 二进制表示与位编号**
假设 `X` 是一个 **8 位无符号整数**，其二进制表示为：
```
X = 45 （十进制） → 二进制：00101101
```
位的编号通常从右到左（从 0 开始）：
```
位编号：7 6 5 4 3 2 1 0
对应值：0 0 1 0 1 1 0 1
```
- **第 0 位**（最右边）是 `1`  
- **第 2 位** 是 `1`  
- **第 5 位** 是 `1`  
- 其余位是 `0`

---

## **2. 右移操作 `X >> n`**
`X >> n` 表示将 `X` 的所有二进制位 **向右移动 `n` 位**，左侧补 `0`。  
例如，查询 **第 2 位**（`n = 2`）：
```
X = 45 → 二进制：00101101
X >> 2 → 右移 2 位：00001011
```
**右移后的结果**：
```
原 X:    00101101
X >> 2:  00001011
```
- **目标位（第 2 位）** 被移动到 **第 0 位**（最右边）。  
- 其他位也被右移，但我们现在只关心 **最低位（第 0 位）**。

---

## **3. 位掩码 `& 1`**
`& 1` 是一个 **位掩码操作**，它只保留数字的 **最低位**，其余位清零。  
继续上面的例子：
```
X >> 2 = 00001011
00001011
&
00000001
---------
00000001  （结果是 1）
```
- **最低位是 `1`** → 结果 `1`（表示第 2 位是 `1`）。  
- 如果最低位是 `0`，结果会是 `0`。

---

## **4. 完整过程示例**
### **示例 1：查询第 2 位（`n = 2`）**
```
X = 45 → 00101101
1. X >> 2 → 00001011
2. 00001011 & 00000001 → 00000001
结果：1 （第 2 位是 1）
```

### **示例 2：查询第 3 位（`n = 3`）**
```
X = 45 → 00101101
1. X >> 3 → 00000101
2. 00000101 & 00000001 → 00000001
结果：1 （第 3 位是 1）
```

### **示例 3：查询第 1 位（`n = 1`）**
```
X = 45 → 00101101
1. X >> 1 → 00010110
2. 00010110 & 00000001 → 00000000
结果：0 （第 1 位是 0）
```

---

## **5. 为什么用 `unsigned int`？**
- **有符号数 (`int`)** 右移时，高位可能补符号位（算术右移），导致错误：
  ```cpp
  int X = -1;  // 二进制：111...1111
  int bit = (X >> 2) & 1;  // 永远是 1（因为右移补 1）
  ```
- **无符号数 (`unsigned int`)** 右移时 **高位补 0**，确保逻辑正确：
  ```cpp
  unsigned int X = 45;
  unsigned int bit = (X >> 2) & 1;  // 正确得到第 2 位
  ```

---

## **总结**
| 操作 | 作用 |
|------|------|
| `X >> n` | 将第 `n` 位移动到最低位（第 0 位） |
| `& 1` | 提取最低位（屏蔽其他位） |
| **组合 `(X >> n) & 1`** | **查询第 `n` 位的值（0 或 1）** |

这个方法是 **高效、跨平台、符合标准** 的位操作技巧，广泛用于嵌入式开发、数据压缩、加密算法等领域。
