`1 << n` 之所以等于 \( 2^n \)，是因为 **左移操作 (`<<`)** 在二进制中相当于 **乘以 2 的幂**。  

### **二进制左移的原理**
1. **`1` 的二进制表示**：
   - `1` 在二进制中是 `0000 0001`（假设 8 位）。
   - `1 << 0` = `0000 0001` = \( 2^0 = 1 \)（不移位）。
   - `1 << 1` = `0000 0010` = \( 2^1 = 2 \)（左移 1 位）。
   - `1 << 2` = `0000 0100` = \( 2^2 = 4 \)（左移 2 位）。
   - `1 << 3` = `0000 1000` = \( 2^3 = 8 \)（左移 3 位）。
   - 依此类推……

2. **数学等价性**：
   - 左移 `n` 位 = 原数 × \( 2^n \)（适用于无符号整数）。
   - 因此，`1 << n` = \( 1 × 2^n = 2^n \)。

### **为什么不用 `pow(2, n)`？**
- `pow(2, n)` 是 **浮点数运算**，可能产生 **精度误差**（如 `pow(2, 30)` 可能返回 `1.07374e+09` 而非准确的 `1073741824`）。
- **移位运算 (`<<`)** 是 **纯整数运算**，速度快且 **100% 精确**，符合题目要求（禁止使用 `pow`）。

### **示例**
```cpp
cout << (1 << 0); // 1 (2^0)
cout << (1 << 1); // 2 (2^1)
cout << (1 << 2); // 4 (2^2)
cout << (1 << 3); // 8 (2^3)
cout << (1 << 4); // 16 (2^4)
```

### **注意**
- **`n` 不能超过类型的位数**（如 `unsigned int` 通常是 32 位，所以 `n` 最大 31，否则 **未定义行为**）。
- **负数不能用左移**（`-1 << 2` 是未定义的，题目要求 `n` 非负）。

### **结论**
`1 << n` 是最优解，因为：
✅ 纯位运算，符合题目要求  
✅ 比 `pow` 更快、更精确  
✅ 直观体现二进制特性
